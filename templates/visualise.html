{% extends "base.html" %}
{% block title %}{{ config['APP_TITLE'] }}{% endblock %}
{% block head %}
{{ super() }}
{% endblock %}

{% block content %}
<style>
    body {
        margin: 0px;
        padding: 0px;
    }

    #wrapper {
        position: relative;
        border: 0px;
        width: 578px;
        height: 200px;
    }

    #buttonWrapper {
        position: relative;
        width: 30px;
        top: 2px;
        right: 2px;
    }

    input[type="button"] {
        padding: 5px;
        width: 30px;
        margin: 0px 0px 2px 0px;
    }
</style>
<h1>VISUALISATIONS</h1>

<body onmousedown="return false;">
    <div id="buttonWrapper">
        <input type="button" id="plus" value="+"><input type="button" id="minus" value="-">
    </div>
    <div id="wrapper style="width:1920px; height:1600px;">
        <canvas id="myCanvas" width="1920" height="1080">
        </canvas>
    </div>
    <!-- <div id="placeholder" style="width:800px; height:800px;">
    <canvas id="myCanvas" style="border:2px solid green;" width="800" height="600"></canvas>

    <!-- <svg id="svg" width="1000px" height="800px"></svg> -->
    <!-- <svg id="svg1" width="100%" height="100%" viewBox="0 0 640 480" preserveAspectRatio="xMaxYMax"></svg> -->
    <!-- </div>  -->
    <!-- <div id="placeholder2"></div> -->


    <!-- WASM GRAPHVIZ -->
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
    <script>
        var hpccWasm = window["@hpcc-js/wasm"];
    </script>

    <script>


        window.addEventListener("load", function (graph) {
            var dotStr = `
        {{ dotStr | safe }}
        `;

            console.log(dotStr);

            // Asynchronous call to layout
            hpccWasm.graphviz.layout(dotStr, "svg", "dot").then(svg => {
                // const div = document.getElementById("placeholder");

                var canvas = document.getElementById('myCanvas');
                var ctx = canvas.getContext('2d');
                var data = svg;
                var DOMURL = window.URL || window.webkitURL || window;
                var img1 = new Image();
                var svg = new Blob([data], { type: 'image/svg+xml' });
                var url = DOMURL.createObjectURL(svg);
                img1.onload = function () {
                    // ctx.drawImage(img1, 25, 70);
                    // ctx.drawImage(img1, 0, 0, img1.width, img1.height, 0, 0, 800, 600);
                    DOMURL.revokeObjectURL(url);
                }
                img1.src = url;


            });

            // hpccWasm.graphvizSync().then(graphviz => {
            //     const div = document.getElementById("placeholder2");
            //     // Synchronous call to layout
            //     div.innerHTML = graphviz.layout(dot, "svg", "dot");
            // });

        });

        //zoom canvas code from https://stackoverflow.com/questions/3420975/html5-canvas-zooming
        function draw(scale, translatePos) {
            var canvas = document.getElementById("myCanvas");
            var context = canvas.getContext("2d");
            var dotStr = `
        {{ dotStr | safe }}
        `;
            // clear canvas

            // Asynchronous call to layout
            //todo: do we need to do all of this again every time? 
            hpccWasm.graphviz.layout(dotStr, "svg", "dot").then(svg => {
                // const div = document.getElementById("placeholder");

                var canvas = document.getElementById('myCanvas');
                var context = canvas.getContext('2d');
                context.clearRect(0, 0, canvas.width, canvas.height);


                var data = svg;
                var DOMURL = window.URL || window.webkitURL || window;
                var img1 = new Image();
                var svg = new Blob([data], { type: 'image/svg+xml' });
                var url = DOMURL.createObjectURL(svg);
                img1.onload = function () {
                    // ctx.drawImage(img1, 25, 70);
                    context.drawImage(img1, 0, 0, img1.width * scale, img1.height * scale, translatePos.x, translatePos.y, canvas.width, canvas.height);
                    DOMURL.revokeObjectURL(url);
                }
                img1.src = url;
                context.save();
                context.translate(translatePos.x, translatePos.y);
                context.scale(scale, scale);
                context.restore();

            });


        }
        //todo: this is the second call to onload() - refactor? 
        window.onload = function () {
            var canvas = document.getElementById("myCanvas");

            var translatePos = {
                // x: canvas.width / 2,
                // y: canvas.height / 2
                 x: 0,
                y: 0
            };

            var scale = 1.0;
            var scaleMultiplier = 0.8;
            var startDragOffset = {};
            var mouseDown = false;

            // add button event listeners
            document.getElementById("plus").addEventListener("click", function () {
                scale *= scaleMultiplier;
                draw(scale, translatePos);
            }, false);

            document.getElementById("minus").addEventListener("click", function () {
                scale /= scaleMultiplier;
                draw(scale, translatePos);
            }, false);

            // add event listeners to handle screen drag
            canvas.addEventListener("mousedown", function (evt) {
                mouseDown = true;
                startDragOffset.x = evt.clientX - translatePos.x;
                startDragOffset.y = evt.clientY - translatePos.y;
            });

            canvas.addEventListener("mouseup", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mouseover", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mouseout", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mousemove", function (evt) {
                if (mouseDown) {
                    translatePos.x = evt.clientX - startDragOffset.x;
                    translatePos.y = evt.clientY - startDragOffset.y;
                    draw(scale, translatePos);
                }
            });

            draw(scale, translatePos);
        }

        // jQuery(document).ready(function () {
        //     $("#wrapper").mouseover(function (e) {
        //         $('#status').html(e.pageX + ', ' + e.pageY);
        //     });
        // })
    </script>
    {% endblock %}

    {%block javascript%}

    {% endblock %}