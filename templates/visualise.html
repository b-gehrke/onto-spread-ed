{% extends "base.html" %}
{% block title %}{{ config['APP_TITLE'] }}{% endblock %}
{% block head %}
{{ super() }}
{% endblock %}

{% block content %}
<style>
    body {
        margin: 0px;
        padding: 0px;
    }

    #wrapper {
        position: relative;
        border: 0px;
        width: 1920px;
        height: 1080px;
    }

    #buttonWrapper {
        position: relative;
        width: 30px;
        top: -1000px;
        left: 25px
    }

    input[type="button"] {
        padding: 5px;
        width: 30px;
        margin: 0px 0px 2px 0px;
    }
</style>
<h1>VISUALISATIONS</h1>

<body onmousedown="return false;">
    <!-- todo: move all styles inline, or at least remove redundancies -->
    <div id="wrapper style=" width:1920px; height:1080px;">
        <canvas id="myCanvas" width="1920" height="1080"></canvas>
        <div id="buttonWrapper">
            <input type="button" id="plus" value="+"><input type="button" id="minus" value="-">
        </div>
    </div>

    <!-- WASM GRAPHVIZ -->
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
    <script>
        var hpccWasm = window["@hpcc-js/wasm"];
    </script>

    <script>
        var loaded = false;
        var img1 = new Image();
        //zoom canvas code from https://stackoverflow.com/questions/3420975/html5-canvas-zooming
        function draw(scale, translatePos) {
            var canvas = document.getElementById("myCanvas");
            var context = canvas.getContext("2d");
            context.clearRect(0, 0, canvas.width, canvas.height);

            //todo: we really shouldn't have to re-do all this every time???
            if (!loaded) {
                var dotStr = `
            {{ dotStr | safe }}
            `;
                // Asynchronous call to layout
                hpccWasm.graphviz.layout(dotStr, "svg", "dot").then(svg => {
                    var data = svg;
                    var DOMURL = window.URL || window.webkitURL || window;

                    var svg = new Blob([data], { type: 'image/svg+xml' });
                    var url = DOMURL.createObjectURL(svg);
                    img1.onload = function () {
                        context.drawImage(img1, 0, 0, img1.width / scale * 2, img1.height / scale * 2, translatePos.x, translatePos.y, img1.width * scale, img1.height * scale);
                        // DOMURL.revokeObjectURL(url);
                    }
                    img1.src = url;
                    loaded = true;
                });
            } else {
                context.drawImage(img1, 0, 0, img1.width / scale * 2, img1.height / scale * 2, translatePos.x, translatePos.y, img1.width * scale, img1.height * scale);
            }
        }

        window.onload = function () {
            var canvas = document.getElementById("myCanvas");

            var translatePos = {
                // x: canvas.width / 2,
                // y: canvas.height / 2
                x: 0,
                y: 0
            };

            var scale = 1.0;
            var scaleMultiplier = 0.8;
            var startDragOffset = {};
            var mouseDown = false;

            // add button event listeners
            document.getElementById("plus").addEventListener("click", function () {
                scale /= scaleMultiplier;
                draw(scale, translatePos);
            }, false);

            document.getElementById("minus").addEventListener("click", function () {
                scale *= scaleMultiplier;
                draw(scale, translatePos);
            }, false);

            // add event listeners to handle screen drag
            canvas.addEventListener("mousedown", function (evt) {
                mouseDown = true;
                startDragOffset.x = evt.clientX - translatePos.x;
                startDragOffset.y = evt.clientY - translatePos.y;
            });

            canvas.addEventListener("mouseup", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mouseover", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mouseout", function (evt) {
                mouseDown = false;
            });

            canvas.addEventListener("mousemove", function (evt) {
                if (mouseDown) {
                    translatePos.x = evt.clientX - startDragOffset.x;
                    translatePos.y = evt.clientY - startDragOffset.y;
                    draw(scale, translatePos);
                }
            });

            draw(scale, translatePos);
        }

        // jQuery(document).ready(function () {
        //     $("#wrapper").mouseover(function (e) {
        //         $('#status').html(e.pageX + ', ' + e.pageY);
        //     });
        // })
    </script>
    {% endblock %}

    {%block javascript%}

    {% endblock %}